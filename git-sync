#!/bin/sh
# Documentation
#   Options:
#       h|help    - help
#       A|all     - add all the files
#       f|file    - list of files to be added
#       m|message - commit message
#       p|push    - push
#       n|no-push - push
#       y|yes     - assume sensible defaults
#
#   Functionality:
#       when no parametres are passed script does not execute
#       -h and --help bring up help (as can be expected)
#       -A and --all is equivalent to running git add -A or git add .
#       -f and --file lists the files to be syncen
#       -m and --message is the same as git commit -m, it stores the commit message
#       -p and --push is push to a remote fter commiting (this behaviour is default)
#       -n and no-push is the opposit of push and keeps the commit local
#       -y and --yes is equivalent to git sync -A -p -m "Modified $files"


# Variables set by the flags
files=""
file=0
message=""
push=1

# Script always requires some options
if [ -z "$1" ]; then
    echo "TODO: usage"
    exit 1
fi

# checking incompatible argumanets
if [ -n "$(echo "$*" | grep -E ".*\-A.*\-f.*|.*\-f.*\-A.*")" ]; then
    echo "-A and -f are incompatibe"
    exit 1
fi

if [ -n "$(echo "$*" | grep -E ".*\-p.*\-n.*|.*\-n.*\-p.*")" ]; then
    echo "-p and -n are incompatibe"
    exit 1
fi

# Main argument collecting loop
while [ -n "$1" ]; do # loop over all arguments

    # Check which arg was passed
    case "$1" in

        -h|-\?)
            if [ "$#" -ne 1 ]; then # if -h is not the only flag, terminate the program.
                echo "-h does not take options and is incompatible with other flags"
                exit 1
            fi
            echo "TODO: a help message"
            ;;



        -A|--all)
            if [ -n "$2" ] && [ "$(echo $2 | cut -c1-1)" != "-" ]; then # if -A ws not the only option terminate the program
                echo "-A does not take options"
                exit 1
            fi

            echo "-A option passed"

            ;;

        -f|--file)
            if [ -z "$2" ] || [ "$(echo $2 | cut -c1-1)" = "-" ]; then # if no files after -f, terminate
                echo "-f requires a list of files"
                exit 1
            fi

            while [ -n "$2" ] && [ "$(echo $2 | cut -c1-1)" != "-" ]; do # a secondary arg collection loop
                files=$(echo "$files" "$2") # collecting all filenames after -f
                shift
            done
            echo "$files"

            ;;

        -m|--message)
            # line -f but without the secondary loop, only collecting one arg after -m
            if [ -z "$2" ]; then
                echo "-m requires a message"
                exit 1
            fi

            if [ "$(echo $2 | cut -c1-1)" = "-" ]; then
                echo "-m requires a message"
                exit 1
            fi

            message="$2"
            echo "-m option passed with message \"$message\""
            shift

            ;;

        -p|--push)
            # just like -A
            if [ -n "$2" ]; then
                if [ "$(echo $2 | cut -c1-1)" != "-" ]; then
                    echo "-p does not take options"
                    exit 1
                fi
            fi

            echo "-p option passed"

            ;;

        -n|--no-push)
            # also like -A
            if [ -n "$2" ]; then
                if [ "$(echo $2 | cut -c1-1)" != "-" ]; then
                    echo "-n does not take options"
                    exit 1
                fi
            fi

            echo "-n option passed"
            ;;

        -y|--yes)
            # same as -h
            if [ "$argNum" -ne 1 ];then
                echo "-y does not take options and is incompatible with other flags"
                exit 1
            fi
            echo "-y option passed"

            ;;

        *)
            # if none of the above matched
            echo "Option $1 not recognized"
            exit 1
            ;;

    esac
    # move to the next argument
    shift

done

addStage() {
    git add
}


